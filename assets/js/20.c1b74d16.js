(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{600:function(e,r,i){"use strict";i.r(r);var v=i(17),s=Object(v.a)({},(function(){var e=this,r=e.$createElement,i=e._self._c||r;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h2",{attrs:{id:"是什么"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[e._v("#")]),e._v(" 是什么")]),e._v(" "),i("p",[e._v("Promise 是 JavaScript 中异步编程新的解决方法。从语法上来讲，它是一个构造函数")]),e._v(" "),i("h3",{attrs:{id:"能干嘛"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#能干嘛"}},[e._v("#")]),e._v(" 能干嘛")]),e._v(" "),i("ol",[i("li",[e._v("指定回调函数方式更灵活")]),e._v(" "),i("li",[e._v("支持链式调用，可以解决回调地狱问题")])]),e._v(" "),i("h2",{attrs:{id:"怎么玩"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#怎么玩"}},[e._v("#")]),e._v(" 怎么玩")]),e._v(" "),i("h3",{attrs:{id:"基本语法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#基本语法"}},[e._v("#")]),e._v(" 基本语法")]),e._v(" "),i("p",[i("code",[e._v("const p = new Promise((resolve,reject)=>{})")])]),e._v(" "),i("ol",[i("li",[e._v("resolve 可以将 Promise 对象设置为「成功」")]),e._v(" "),i("li",[e._v("reject 可以将 Promise 对象设置为「失败」")]),e._v(" "),i("li",[e._v("then((value)=>{},(reason)=>{})")])]),e._v(" "),i("h3",{attrs:{id:"promise-对象的状态"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象的状态"}},[e._v("#")]),e._v(" Promise 对象的状态")]),e._v(" "),i("p",[e._v("实例对象中的一个属性 PromiseState")]),e._v(" "),i("ol",[i("li",[e._v("pending：")]),e._v(" "),i("li",[e._v("resolved/fullfilled：成功")]),e._v(" "),i("li",[e._v("rejected：失败")])]),e._v(" "),i("p",[e._v("实例对象中的属性(异步任务执行的结果值) PromiseResult")]),e._v(" "),i("ol",[i("li",[e._v("resolve")]),e._v(" "),i("li",[e._v("reject")])]),e._v(" "),i("h3",{attrs:{id:"promise-api"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#promise-api"}},[e._v("#")]),e._v(" Promise API")]),e._v(" "),i("ol",[i("li",[e._v("Promise 构造函数接收执行器函数 executor。executor 会在Promise内部立即同步调用，异步操作在执行器中")]),e._v(" "),i("li",[e._v("Promise.prototype.then")]),e._v(" "),i("li",[e._v("Promise.prototype.catch")]),e._v(" "),i("li",[e._v("Promise.resolve()：\n"),i("ol",[i("li",[e._v("如果参数为非promise对象，则返回结果为成功的promise对象")]),e._v(" "),i("li",[e._v("如果参数为promise对象，则参数对象的结果决定了 resolve 结果")])])]),e._v(" "),i("li",[e._v("Promise.reject()：返回一个失败的 promise 对象")]),e._v(" "),i("li",[e._v("Promise.all()：接收 promise 数组参数，")]),e._v(" "),i("li",[e._v("Promise.race()：接收 promise 数组参数，返回第一个完成 promise 对象的结果")])]),e._v(" "),i("h3",{attrs:{id:"promise-关键问题"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#promise-关键问题"}},[e._v("#")]),e._v(" promise 关键问题")]),e._v(" "),i("ol",[i("li",[e._v("如何改变 promise 对象状态\n"),i("ol",[i("li",[e._v("调用 resolve()")]),e._v(" "),i("li",[e._v("调用 reject()")]),e._v(" "),i("li",[e._v("抛出异常 throw")])])]),e._v(" "),i("li",[e._v("promise 能否指定多个成功/失败的回调方法，这些方法都会执行吗？ YES")]),e._v(" "),i("li",[e._v("是 promise 状态先改变还是 then 回调函数先执行\n"),i("ol",[i("li",[e._v("都有可能")]),e._v(" "),i("li",[e._v("promise executor 为同步任务时（直接调或延迟then），先改变状态，后执行then")]),e._v(" "),i("li",[e._v("为异步任务时，先执行 then，再改变状态")])])]),e._v(" "),i("li",[e._v("什么时候能拿到数据\n"),i("ol",[i("li",[e._v("同步方法：")]),e._v(" "),i("li",[e._v("异步方法：改变状态后，再调用 then 指定的回调函数")])])]),e._v(" "),i("li",[e._v("promise.then 返回结果是 promise 对象，该对象的状态由什么决定")]),e._v(" "),i("li",[e._v("promise 如何串联多个操作任务")]),e._v(" "),i("li",[e._v("promise 异常穿透")]),e._v(" "),i("li",[e._v("中断 promise 链\n"),i("ol",[i("li",[e._v("有且只有一种方式，返回一个 pending 状态的 promise 对象")])])])]),e._v(" "),i("h2",{attrs:{id:"async-和-await"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#async-和-await"}},[e._v("#")]),e._v(" async 和 await")]),e._v(" "),i("ol",[i("li",[e._v("async 修饰函数，该函数返回 promise 对象")])])])}),[],!1,null,null,null);r.default=s.exports}}]);