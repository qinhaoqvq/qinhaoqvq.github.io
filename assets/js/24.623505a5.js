(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{608:function(a,s,t){"use strict";t.r(s);var e=t(17),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[a._v("#")]),a._v(" 是什么")]),a._v(" "),t("p",[a._v("可以将一个类的定义放在另一个类的定义内部，这就是内部类")]),a._v(" "),t("h2",{attrs:{id:"能干嘛"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#能干嘛"}},[a._v("#")]),a._v(" 能干嘛")]),a._v(" "),t("p",[a._v("内部类可以继承多个具体的或抽象的类的能力，这使得"),t("code",[a._v("多重继承")]),a._v(" 的解决方法变得完整。接口解决了部分问题，而内部类有效地实现了"),t("code",[a._v("多重继承")])]),a._v(" "),t("h2",{attrs:{id:"不同的内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不同的内部类"}},[a._v("#")]),a._v(" 不同的内部类")]),a._v(" "),t("blockquote",[t("p",[a._v("在类中定义的内部类，是可以在外部类中创建其对象的。但是，在方法和作用域中定义的内部类，一旦出了方法和作用域的范围，这个内部类便不可以再被访问")])]),a._v(" "),t("h3",{attrs:{id:"类中的内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类中的内部类"}},[a._v("#")]),a._v(" 类中的内部类")]),a._v(" "),t("ul",[t("li",[a._v("在外部类的非静态方法之外的位置创建内部类对象，必须使用"),t("code",[a._v("OuterClassName.InnerClassName")]),a._v(" 的方式"),t("code",[a._v("指明这个对象的类型")])]),a._v(" "),t("li",[a._v("必须使用外部类的对象来创建内部类的对象（静态内部类不必需要）\n"),t("ul",[t("li",[a._v("✨因为内部类的对象会拥有外部类对象的引用")])])]),a._v(" "),t("li",[a._v("内部类可以访问外部类的所有成员")]),a._v(" "),t("li",[a._v("内部类可以访问外部类对象的所有成员（通过"),t("code",[a._v("OuterClassName.this")]),a._v("获取外部类对象）")]),a._v(" "),t("li",[a._v("内部类定义的类型（如变量）会屏蔽其作用域范围内的其他同名类型（变量）")]),a._v(" "),t("li",[a._v("继承会把内部类一起继承，内部类就是外部类的一部分，属于它的成员")])]),a._v(" "),t("h4",{attrs:{id:"this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[a._v("#")]),a._v(" .this")]),a._v(" "),t("p",[a._v("在内部类生成外部类对象的引用，"),t("code",[a._v("OuterClassName.this")]),a._v("，在内部类显示的使用外部类对象")]),a._v(" "),t("h4",{attrs:{id:"new"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new"}},[a._v("#")]),a._v(" .new")]),a._v(" "),t("p",[a._v("创建某个对象内部类的对象时，需要使用该语法，"),t("code",[a._v("OuterClassInstance.new InnerClassName()")])]),a._v(" "),t("h3",{attrs:{id:"方法和作用域中的内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法和作用域中的内部类"}},[a._v("#")]),a._v(" 方法和作用域中的内部类")]),a._v(" "),t("p",[a._v("方法和作用域中的内部类也是其一部分，离开了方法和作用域其内部类便不可访问")]),a._v(" "),t("h3",{attrs:{id:"匿名内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#匿名内部类"}},[a._v("#")]),a._v(" 匿名内部类")]),a._v(" "),t("p",[a._v("匿名内部类不能访问定义在外部类未加final修饰的对象（JDK1.8之后不加final也可以访问）")]),a._v(" "),t("h3",{attrs:{id:"嵌套类-静态内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#嵌套类-静态内部类"}},[a._v("#")]),a._v(" 嵌套类（静态内部类）")]),a._v(" "),t("ul",[t("li",[a._v("嵌套类与外部类对象之间无联系，即，嵌套类的对象"),t("code",[a._v("不会")]),a._v("拥有外部类对象的引用")]),a._v(" "),t("li",[a._v("嵌套类不可以访问外部类的任何的"),t("code",[a._v("非静态")]),a._v("成员")]),a._v(" "),t("li",[a._v("嵌套类可以定义static的变量和static的方法")])]),a._v(" "),t("h4",{attrs:{id:"接口内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口内部类"}},[a._v("#")]),a._v(" 接口内部类")]),a._v(" "),t("p",[a._v("如果想要创建某些公共的代码，使得它们可以被某个接口的所有不同实现所共用，那么就可以使用接口内部类（"),t("code",[a._v("接口内部类都是public和static的")]),a._v("）")]),a._v(" "),t("h3",{attrs:{id:"局部内部类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#局部内部类"}},[a._v("#")]),a._v(" 局部内部类")]),a._v(" "),t("h4",{attrs:{id:"定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[a._v("#")]),a._v(" 定义")]),a._v(" "),t("p",[a._v("在代码块中创建的没有访问修饰符的内部类，就是局部内部类")]),a._v(" "),t("h4",{attrs:{id:"特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[a._v("#")]),a._v(" 特性")]),a._v(" "),t("p",[a._v("局部内部类与匿名内部类具有相同的行为和能力，在代码块之外的位置是不可见的，都可以访问当前代码块内的常量（final修饰的对象）以及此外部类的所有成员")]),a._v(" "),t("h4",{attrs:{id:"能干嘛-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#能干嘛-2"}},[a._v("#")]),a._v(" 能干嘛")]),a._v(" "),t("p",[a._v("局部内部类有一个已命名的构造方法，支持重载构造方法或者创建多个该内部类的对象")]),a._v(" "),t("h2",{attrs:{id:"内部类的继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内部类的继承"}},[a._v("#")]),a._v(" 内部类的继承")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WithInner")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Inner")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("InheritInner")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WithInner"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Inner")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// public InheritInner() 编译报错")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 子类构造方法不仅需要传递外部类对象的引用, 而且还需要执行外部类对象.super()")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("InheritInner")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WithInner")]),a._v(" wi"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        wi"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("super")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("h2",{attrs:{id:"内部类不可以被覆盖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内部类不可以被覆盖"}},[a._v("#")]),a._v(" 内部类不可以被覆盖")]),a._v(" "),t("blockquote",[t("p",[a._v("新建一个类继承了外部类A，并创建了与外部类A中的内部类A1同名的内部类，两个内部类无明显变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内")])]),a._v(" "),t("h2",{attrs:{id:"内部类标识符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内部类标识符"}},[a._v("#")]),a._v(" 内部类标识符")]),a._v(" "),t("blockquote",[t("p",[a._v("由于每个类都会产生一个.class文件，其中包含了如何创建该类型的对象的全部信息（此信息生成一个Class对象），那么内部类也必须生成一个.class文件以包含它们的Class对象信息。这些类文件的命名是有规则的：OuterClassName$InnerClassName.class，"),t("code",[a._v("如果匿名内部类，编译器会生成一个数字作为其标识符")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);